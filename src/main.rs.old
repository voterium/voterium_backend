use actix_web::{get, post, web, App, HttpResponse, HttpServer, Responder, Error, HttpMessage};
use actix_web::body::{BoxBody, EitherBody, MessageBody};
use actix_web::dev::{Service, ServiceRequest, ServiceResponse, Transform};
use futures::future::{ok, Ready, LocalBoxFuture};
use jsonwebtoken::{decode, Algorithm, Validation, DecodingKey};
use serde::{Deserialize, Serialize};
use sqlx::{SqlitePool};
use std::env;
use std::sync::Arc;


#[derive(Debug, Deserialize)]
struct Claims {
    sub: String,
    exp: usize,
}

// Authentication middleware
struct AuthMiddleware {
    public_key: Vec<u8>,
}


impl AuthMiddleware {
    fn new(public_key: Vec<u8>) -> Self {
        Self { public_key }
    }
}

impl<S, B> Service<ServiceRequest> for AuthMiddlewareMiddleware<S>
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error> + 'static,
    B: MessageBody + 'static,
{
    type Response = ServiceResponse<EitherBody<B, BoxBody>>;
    type Error = Error;
    type Transform = AuthMiddlewareMiddleware<S>;
    type InitError = ();
    type Future = Ready<Result<Self::Transform, Self::InitError>>;

    fn new_transform(&self, service: S) -> Self::Future {
        ok(AuthMiddlewareMiddleware {
            service: Arc::new(service),
            public_key: self.public_key.clone(),
        })
    }
}


struct AuthMiddlewareMiddleware<S> {
    service: Arc<S>,
    public_key: Vec<u8>,
}

impl<S, B> Service<ServiceRequest> for AuthMiddlewareMiddleware<S>
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error> + 'static,
    B: MessageBody + 'static,
{
    type Response = ServiceResponse<B>;
    type Error = Error;
    type Future = LocalBoxFuture<'static, Result<Self::Response, Self::Error>>;

    actix_web::dev::forward_ready!(service);

    fn call(&self, req: ServiceRequest) -> Self::Future {
        let public_key = self.public_key.clone();
        let service = self.service.clone(); // Clone the Arc<S>
        let path = req.path().to_string();
        let mut req = req;
    
        Box::pin(async move {
            if path == "/auth/login" || path == "/auth/register" || path == "/results" {
                let res = service.call(req).await?;
                Ok(res.map_into_left_body())
            } else {
                // Extract and verify the token
                if let Some(auth_header) = req.headers().get("Authorization") {
                    if let Ok(auth_str) = auth_header.to_str() {
                        if auth_str.starts_with("Bearer ") {
                            let token = &auth_str[7..];
                            let decoding_key = DecodingKey::from_ed_pem(&public_key)
                                .map_err(|_| Error::from(HttpResponse::InternalServerError()))?;
                            let validation = Validation::new(Algorithm::EdDSA);
                            match decode::<Claims>(&token, &decoding_key, &validation) {
                                Ok(token_data) => {
                                    // Attach user_id to the request extensions
                                    req.extensions_mut().insert(token_data.claims.sub);
                                    let res = service.call(req).await?;
                                    return Ok(res.map_into_left_body());
                                }
                                Err(_) => {
                                    let res = HttpResponse::Unauthorized().finish();
                                    return Ok(req.into_response(res.map_into_right_body()));
                                }
                            }
                        }
                    }
                }
                let res = HttpResponse::Unauthorized().finish();
                Ok(req.into_response(res.map_into_right_body()))
            }
        })
    }
}

#[derive(Deserialize)]
struct Vote {
    choice: String,
}

#[derive(Serialize, sqlx::FromRow)]
struct VoteCount {
    choice: String,
    count: i64,
}

#[post("/vote")]
async fn submit_vote(
    vote: web::Json<Vote>,
    db_pool: web::Data<SqlitePool>,
    req: actix_web::HttpRequest,
) -> impl Responder {
    // Get user_id from request extensions
    let user_id = if let Some(uid) = req.extensions().get::<String>() {
        uid.clone()
    } else {
        return HttpResponse::Unauthorized().body("Unauthorized");
    };

    let query = "INSERT INTO votes (user_id, choice, timestamp) VALUES (?, ?, strftime('%s','now'))";
    match sqlx::query(query)
        .bind(&user_id)
        .bind(&vote.choice)
        .execute(db_pool.get_ref())
        .await
    {
        Ok(_) => HttpResponse::Ok().body("Vote submitted successfully."),
        Err(e) => {
            eprintln!("Database error: {}", e);
            HttpResponse::InternalServerError().body("Failed to submit vote.")
        }
    }
}

#[get("/results")]
async fn get_results(db_pool: web::Data<SqlitePool>) -> impl Responder {
    let query = r#"
        SELECT choice, COUNT(*) as count FROM (
            SELECT user_id, choice FROM votes
            GROUP BY user_id
            HAVING MAX(timestamp)
        ) GROUP BY choice;
    "#;
    match sqlx::query_as::<_, VoteCount>(query)
        .fetch_all(db_pool.get_ref())
        .await
    {
        Ok(results) => HttpResponse::Ok().json(results),
        Err(e) => {
            eprintln!("Database error: {}", e);
            HttpResponse::InternalServerError().body("Failed to fetch results.")
        }
    }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Load environment variables
    dotenv::dotenv().ok();
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");

    // Read public key
    let public_key_path = env::var("JWT_PUBLIC_KEY_PATH").expect("JWT_PUBLIC_KEY_PATH must be set");
    let public_key = std::fs::read(public_key_path).expect("Failed to read public key");

    // Create database pool
    let db_pool = SqlitePool::connect(&database_url)
        .await
        .expect("Failed to connect to the database.");

    // Create the votes table if it doesn't exist
    sqlx::query(
        r#"
        CREATE TABLE IF NOT EXISTS votes (
            id INTEGER PRIMARY KEY,
            user_id TEXT NOT NULL,
            choice TEXT NOT NULL,
            timestamp INTEGER NOT NULL
        );
        "#,
    )
    .execute(&db_pool)
    .await
    .expect("Failed to create table.");

    // Start HTTP server
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(db_pool.clone()))
            .wrap(AuthMiddleware::new(public_key.clone()))
            .service(submit_vote)
            .service(get_results)
    })
    .bind(("0.0.0.0", 8080))?
    .run()
    .await
}
